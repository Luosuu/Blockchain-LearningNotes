# 区块是怎么连接的？
在区块链和以太坊中，每个区块都连接着另外一个区块，区块依次相连，形成一条长链。其中第一个区块成为**创世区块**。创世区块通过`genesis.json`文件产生。  
区块链中，两个相邻的区块之间是父子的关系，并且是一对一的关系（每个子都只有一个父）。那么如何确认这种关系并且将他们连接在一起呢？  
每个区块都由两个部分组成，区块头和区块体。其中区块头存储着当前区块的特征值，它包含了很多属性，如生成该区块的时间，本区块的区块体的散列，上一个区块的散列...  
通过上一个区块的散列这一属性，我们就将区块连接在一起了，并且可以互相认证。由于散列的特殊性，如果区块体的内容改变，那么她的散列一定会改变，那么就会连锁性质的导致它的子块，和子块下面的所有块都要改变。而快速改变多个区块是几乎不可能的，这要求它占据全网51%的算力。这样的方式保证了区块链的不可篡改性质。  
# 区块体的散列值的产生-Merkle根数
Merkle根叔，又称哈希二叉树(Merkle tree)。每个被储存在区块里的交易都会产生一个散列值，然后挖矿程序会将它们随机地两个一组两个一组的分组，每个组的两个成员的哈希值相连接成为一个长字符串，然后在对其产生哈希，然后不断重复分组-相连-产生哈希的过程，最终生成最后的一个哈希值，这就是Merkle根哈希值(Merkle root)。
## Merkle tree有什么用？
在说这个之前，我们要提一句另外一种产生一系列内容的哈希值的方式，Hash List。  
Hash List非常简单，就是对每一项内容都产生一个哈希，把这些哈希放进一个列表里，也就是Hash List，然后把这些哈希全都连接在一起，在对其产生一个哈希，用来检验Hash List。那么我为了验证从不可信源下载的内容的正确性，每次都要下载整个内容，生成完整的Hash List，然后产生哈希，和公开可信的那个哈希值进行对比。如果这个内容很大，就很不方便了。  
通过Merkle tree这种方式产生哈希，在P2P网络下载整个网络之前，我们可以先从可信源获得Merkle root，然后从其他不可信源下载Merkle tree，对比二者的Merkle root，由于哈希值的唯一性，我们可以认为如果Merkle root一致，那么整个Merkle tree都是正确的。  
如果我们只需要从源中下载内容里的一部分数据，我们只需要从那些不可信源里下载那一部分就行了，然后对比它所对应的Merkle tree的分支，从而不必下载整个内容再对比。如果我们的内容的一部分损坏了，那么也只需要下载那一部分然后对比对应树上的哈希就行了。
