# solidity的数据类型和结构

## 数据类型

solidity中的数据都属于两种类型，一个是值类型，一个是引用类型。solidity并没有所谓指针的存在。但是它的各种实现本质上还是要依赖指针。值类型会创建独立的副本，并且互相独立。在一个值的改变后，不会影响到其他值。而引用类型变量中的值如果改变，那么任何引用这个变量的地方的值都会更新。

### 值类型

值类型变量会直接保存在内存中。EVM会为他们分配独立的空间。值类型大小被限制在32字节。solidity提供了以下值类型：

* bool
* uint：无符号整数，只可以存0和正值
* int：有符号整数
* address
* byte：字节数组
* enum：保存预定义常量值的枚举

在solidity中的函数如果参数使用值传递，那么将不会影响到愿变量。

### 引用类型

引用类型可以占用32字节以上的内存。他们不直接储存值，而是储存值的地址。该变量保存了一个实际储存数据的内存位置的指针。

solidity提供以下引用类型

* 数组
* 结构(struct)
* 字符串(string)
* 映射(mapping)

在solidity的函数中使用引用传递，由于使用地址更改，所以会影响到原变量。

## 数据位置

在合约中声明和使用每个变量自然都需要又一个储存值的数据位置。EVM提供以下四种用于存储变量的数据结构：

* 存储
* 内存
* 调用数据
* 堆栈

**存储**可以被合约内所有的函数访问，这意味着它是全局内存变量。以太坊将其存储在每个节点上永久储存。

**内存**是属于函数内部的，当函数执行完毕，就会被销毁。合约中的每个函数都可以访问本地内存来暂时保存这些变量。

**调用数据**存储所有传入的函数执行数据，包括函数参数，这是个不可以改变的内存位置。

**堆栈**：EVM用于加在变量和使用以太坊指令集和中间值的堆栈。这是EVM的工作集内存，在EVM中，堆栈的深度为1024层，任何超过此数量的深度都会引发异常。

变量的数据位置取决于两点：

* 变量声明的位置
* 变量的数据类型
